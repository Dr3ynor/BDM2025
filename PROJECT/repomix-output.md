This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-10 17:58:39

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
contracts
  CrowdFunding.sol
frontend
  public
    index.html
  src
    App.js
    components
      ProjectDetail.js
      ProjectList.js
      ProjectForm.js
    utils
      contract.js
      CrowdFunding.json
    index.js
  package.json
deploy.js
compiled_code.json
```

# Repository Files


## contracts/CrowdFunding.sol

```text
pragma solidity ^0.8.0;

contract CrowdFunding {
    struct Project {
        address payable creator;
        uint goal;
        uint deadline;
        string name;
        string description;
        string imageUrl;
        uint totalFunds;
        bool withdrawn;
        address[] funders;
        mapping(address => uint) contributions;
    }

    uint public projectCount;
    mapping(uint => Project) private projects;

    event ProjectCreated(uint id, address creator);
    event Funded(uint id, address funder, uint amount);
    event Refunded(uint id, address funder, uint amount);
    event Withdrawn(uint id);

    function createProject(string memory _name, string memory _description, string memory _imageUrl, uint _goal, uint _deadline) public {
        require(_deadline > block.timestamp, "Deadline must be in future");
        Project storage p = projects[projectCount];
        p.creator = payable(msg.sender);
        p.name = _name;
        p.description = _description;
        p.imageUrl = _imageUrl;
        p.goal = _goal;
        p.deadline = _deadline;
        emit ProjectCreated(projectCount, msg.sender);
        projectCount++;
    }

    function fundProject(uint _id) public payable {
        Project storage p = projects[_id];
        require(block.timestamp < p.deadline, "Deadline passed");
        require(msg.value > 0, "Must send ETH");
        if (p.contributions[msg.sender] == 0) {
            p.funders.push(msg.sender);
        }
        p.contributions[msg.sender] += msg.value;
        p.totalFunds += msg.value;
        emit Funded(_id, msg.sender, msg.value);
    }

    function withdraw(uint _id) public {
        Project storage p = projects[_id];
        require(msg.sender == p.creator, "Only creator");
        require(block.timestamp >= p.deadline, "Deadline not reached");
        require(p.totalFunds >= p.goal, "Goal not reached");
        require(!p.withdrawn, "Already withdrawn");
        p.withdrawn = true;
        p.creator.transfer(p.totalFunds);
        emit Withdrawn(_id);
    }

    function refund(uint _id) public {
        Project storage p = projects[_id];
        require(block.timestamp >= p.deadline, "Deadline not reached");
        require(p.totalFunds < p.goal, "Goal was reached");
        uint amount = p.contributions[msg.sender];
        require(amount > 0, "No contribution");
        p.contributions[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
        emit Refunded(_id, msg.sender, amount);
    }

    function getProject(uint _id) public view returns (
        address creator,
        uint goal,
        uint deadline,
        string memory name,
        string memory description,
        string memory imageUrl,
        uint totalFunds,
        bool withdrawn
    ) {
        Project storage p = projects[_id];
        return (p.creator, p.goal, p.deadline, p.name, p.description, p.imageUrl, p.totalFunds, p.withdrawn);
    }

    function getContribution(uint _id, address _funder) public view returns (uint) {
        return projects[_id].contributions[_funder];
    }

    function getFunders(uint _id) public view returns (address[] memory) {
        return projects[_id].funders;
    }
}
```

## frontend/public/index.html

```html
<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Crowdfunding DApp</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>
```

## frontend/src/App.js

```javascript
import React, { useEffect, useState } from "react";
import { ethers } from "ethers";
import ProjectForm from "./components/ProjectForm";
import ProjectList from "./components/ProjectList";
import ProjectDetail from "./components/ProjectDetail";

function App() {
  const [provider, setProvider] = useState(null);
  const [selectedProject, setSelectedProject] = useState(null);

  useEffect(() => {
    if (window.ethereum) {
      setProvider(new ethers.BrowserProvider(window.ethereum));
    } else {
      alert("Nainstalujte si MetaMask");
    }
  }, []);

  return (
    <div>
      <h1>Ethereum Crowdfunding</h1>
      {provider && <ProjectForm provider={provider} />}
      {provider && !selectedProject && <ProjectList provider={provider} onSelect={setSelectedProject} />}
      {provider && selectedProject !== null && <ProjectDetail id={selectedProject} provider={provider} />}
    </div>
  );
}

export default App;
```

## frontend/src/components/ProjectDetail.js

```javascript
import React, { useEffect, useState } from "react";
import { getContract } from "../utils/contract";
import { ethers } from "ethers";

export default function ProjectDetail({ id, provider }) {
  const [project, setProject] = useState(null);
  const [amount, setAmount] = useState("");

  useEffect(() => {
    const fetch = async () => {
      const contract = getContract(provider);
      const p = await contract.getProject(id);
      setProject(p);
    };
    fetch();
  }, [id]);

  const fund = async () => {
    const signer = provider.getSigner();
    const contract = getContract(signer);
    await contract.fundProject(id, { value: ethers.parseEther(amount) });
  };

  const refund = async () => {
    const signer = provider.getSigner();
    const contract = getContract(signer);
    await contract.refund(id);
  };

  const withdraw = async () => {
    const signer = provider.getSigner();
    const contract = getContract(signer);
    await contract.withdraw(id);
  };

  if (!project) return <div>Načítání...</div>;

  return (
    <div>
      <h2>{project.name}</h2>
      <p>{project.description}</p>
      <p>Vybráno: {ethers.formatEther(project.totalFunds)} ETH</p>
      <p>Cíl: {ethers.formatEther(project.goal)} ETH</p>
      <p>Deadline: {new Date(Number(project.deadline) * 1000).toLocaleString()}</p>
      <input placeholder="částka v ETH" onChange={e => setAmount(e.target.value)} />
      <button onClick={fund}>Investovat</button>
      <button onClick={refund}>Refund</button>
      <button onClick={withdraw}>Vybrat</button>
    </div>
  );
}
```

## frontend/src/components/ProjectList.js

```javascript
/*import React, { useEffect, useState } from "react";
import { getContract } from "../utils/contract";

export default function ProjectList({ provider, onSelect }) {
  const [projects, setProjects] = useState([]);

  useEffect(() => {
    const fetchProjects = async () => {
      const contract = getContract(provider);
      const count = await contract.projectCount();
      const all = [];
      for (let i = 0; i < count; i++) {
        const p = await contract.getProject(i);
        all.push({ id: i, ...p });
      }
      setProjects(all);
    };
    fetchProjects();
  }, [provider]);

  return (
    <div>
      {projects.map(p => (
        <div key={p.id}>
          <h3>{p.name}</h3>
          <p>{p.description}</p>
          <button onClick={() => onSelect(p.id)}>Detail</button>
        </div>
      ))}
    </div>
  );
}
*/



import React, { useEffect, useState } from "react";
import { ethers } from "ethers";
import { getContract } from "../utils/contract";

export default function ProjectList({ provider, onSelect }) {
  const [projects, setProjects] = useState([]);

  useEffect(() => {
    const fetchProjects = async () => {
      // Ensure we're using a Signer for contract interaction
      const signer = provider.getSigner();
      const contract = getContract(signer); // Pass the signer instead of just provider
      
      const count = await contract.projectCount();
      const all = [];
      for (let i = 0; i < count; i++) {
        const p = await contract.getProject(i);
        all.push({ id: i, ...p });
      }
      setProjects(all);
    };
    fetchProjects();
  }, [provider]);

  return (
    <div>
      {projects.map(p => (
        <div key={p.id}>
          <h3>{p.name}</h3>
          <p>{p.description}</p>
          <button onClick={() => onSelect(p.id)}>Detail</button>
        </div>
      ))}
    </div>
  );
}
```

## frontend/src/components/ProjectForm.js

```javascript
import React, { useState } from "react";
import { getContract } from "../utils/contract";
import { ethers } from "ethers";

export default function ProjectForm({ provider }) {
  const [name, setName] = useState("");
  const [desc, setDesc] = useState("");
  const [goal, setGoal] = useState("");
  const [deadline, setDeadline] = useState("");
  const [imageUrl, setImageUrl] = useState("");

  const handleCreate = async () => {
    const signer = provider.getSigner();
    const contract = getContract(signer);
    await contract.createProject(name, desc, imageUrl, ethers.parseEther(goal), Math.floor(new Date(deadline).getTime() / 1000));
  };

  return (
    <div>
      <input placeholder="Název" onChange={e => setName(e.target.value)} />
      <input placeholder="Popis" onChange={e => setDesc(e.target.value)} />
      <input placeholder="Obrázek URL" onChange={e => setImageUrl(e.target.value)} />
      <input placeholder="Cílová částka v ETH" onChange={e => setGoal(e.target.value)} />
      <input type="datetime-local" onChange={e => setDeadline(e.target.value)} />
      <button onClick={handleCreate}>Vytvořit projekt</button>
    </div>
  );
}
```

## frontend/src/utils/contract.js

```javascript
import { ethers } from "ethers";
import contractData from "./CrowdFunding.json";  // správný import// Deployed at: 0x947Ad442A93Cc5270aaC236De240e5CA3111565d
const CONTRACT_ADDRESS = "0x947Ad442A93Cc5270aaC236De240e5CA3111565d";

export function getContract(signerOrProvider) {
  return new ethers.Contract(
    CONTRACT_ADDRESS, 
    contractData.contracts["contracts/CrowdFunding.sol"].CrowdFunding.abi,  // přístup k ABI
    signerOrProvider
  );
}
```

## frontend/src/index.js

```javascript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

## frontend/package.json

```json
{
  "name": "crowdfunding-dapp",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "ethers": "^6.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-scripts": "^5.0.0"
  },
  "scripts": {
    "start": "react-scripts start"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

## deploy.js

```javascript
#!/usr/bin/env node
const { default: Web3 } = require('web3');
const fs = require('fs');
const solc = require('solc');

class ContractDeploy {
  constructor(providerUrl, privateKey) {
    this.web3 = new Web3(providerUrl);

    this.account = this.web3.eth.accounts.privateKeyToAccount(privateKey);
    this.web3.eth.accounts.wallet.add(this.account);
    this.web3.eth.defaultAccount = this.account.address;
  }

  async compileContract(filePath) {
    const source = fs.readFileSync(filePath, 'utf8');

    const input = {
      language: 'Solidity',
      sources: { [filePath]: { content: source } },
      settings: {
        outputSelection: { '*': { '*': ['abi', 'evm.bytecode'] } }
      }
    };

    const output = JSON.parse(solc.compile(JSON.stringify(input)));
    if (output.errors) {
      const fatals = output.errors.filter(e => e.severity === 'error');
      if (fatals.length) throw new Error(fatals.map(e => e.formattedMessage).join('\n'));
    }

    fs.writeFileSync('compiled_code.json', JSON.stringify(output, null, 2));
    return output;
  }

  async deployContract(contractFile, contractName, gasLimit, gasPriceGwei) {
    const compiled = JSON.parse(fs.readFileSync('compiled_code.json'));
    const { abi, evm: { bytecode } } = compiled.contracts[contractFile][contractName];

    const contract = new this.web3.eth.Contract(abi);
    const deployTx = contract.deploy({ data: '0x' + bytecode.object });

    const receipt = await deployTx.send({
      from: this.account.address,
      gas: gasLimit,
      gasPrice: this.web3.utils.toWei(gasPriceGwei.toString(), 'gwei')
    });

    this.contractInstance = new this.web3.eth.Contract(abi, receipt.options.address);
    return receipt.options.address;
  }

  async callFunction(functionName, args = [], gasLimit, gasPriceGwei) {
    if (!this.contractInstance) throw new Error('Nejprve deploy nebo load_contract');
    const tx = this.contractInstance.methods[functionName](...args);
    const receipt = await tx.send({
      from: this.account.address,
      gas: gasLimit,
      gasPrice: this.web3.utils.toWei(gasPriceGwei.toString(), 'gwei')
    });
    return receipt;
  }

  async getValue(functionName) {
    if (!this.contractInstance) throw new Error('Nejprve deploy nebo load_contract');
    return this.contractInstance.methods[functionName]().call();
  }

  loadContract(address, abi) {
    this.contractInstance = new this.web3.eth.Contract(abi, address);
  }
}

(async () => {
  try {
    const provider = 'https://eth-sepolia.g.alchemy.com/v2/rDYp4Dri6cGm-Mijy8kFx6NVnS4B_5kR';
    const pk       = '0x35b3a2fcf1d44773596b2bf27776ee908c05273ef86aa518ba59dd6ab0638522';
    const deployer = new ContractDeploy(provider, pk);

    await deployer.compileContract('contracts/CrowdFunding.sol');

    const addr = await deployer.deployContract('contracts/CrowdFunding.sol', 'CrowdFunding', 2_000_000, 50);
    console.log('Deployed at:', addr);

    const txr = await deployer.callFunction('set', [123], 200_000, 50);
    console.log('set() tx hash:', txr.transactionHash);

    const val = await deployer.getValue('get');
    console.log('Value is:', val);
  } catch (e) {
    console.error(e);
  }
})();
```

## Statistics

- Total Files: 10
- Total Characters: 116579
- Total Tokens: 0
